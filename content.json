[{"title":"webpack填坑第一弹","date":"2017-06-24T13:12:33.000Z","path":"2017/06/24/webpack填坑第一弹/","text":"webpack是用来干什么？webpack是一个现代JavaScript应用模块打包工具。把你的所有依赖递归打包到一小撮bundles（通常是一个），让浏览器可以加载。重点掌握四大核心概念：Entry,Output,Loaders,Plugins Entry顾名思义，入口文件。webpack打包的起点，告诉webpack从哪里开始干 单入口文件123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; 对象语法123456const config = &#123; entry: &#123; app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; &#125;&#125;; 多页面应用当每个页面有不同的依赖图时1234567const config = &#123; entry: &#123; pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; &#125;&#125;; Output输出文件，告诉webpack把打包好的东西用什么标签（filename文件名）放在哪里（path）用什么方法编译（output options） 单入口最少要一个文件名和一个路径1234567&#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;bundle.js&apos;, path: __dirname + &apos;/build&apos; &#125;&#125; 多入口[name][hash][chunkhash]12345678910&#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/build&apos; &#125;&#125; 常用的操作optionsLoaders把浏览器不认识的变成浏览器认识的加工工具统一在这里进行分配 For example如果你要webpack加载一个css文件或者把typescript转成JavaScript,都是由Loaders把各个文件分配给各个单位（loader）去执行 1.安装12npm install --save-dev css-loadernpm install --save-dev ts-loader 2.设置webpack.config.js12345678module.exports = &#123; module: &#123; rules: [ &#123;test: /\\.css$/, use: &apos;css-loader&apos;&#125;, &#123;test: /\\.ts$/, use: &apos;ts-loader&apos;&#125; ] &#125;&#125;; PluginsPlugins是webpack的脊梁？？？问号脸？？？Plugins操作用来自定义webpack的编译流程,需要用一些插件来进行处理时12345678910111213141516171819202122232425262728293031var webpack = require(&apos;webpack&apos;)// importing plugins that do not come by default in webpackvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);var DashboardPlugin = require(&apos;webpack-dashboard/plugin&apos;);// adding plugins to your configurationplugins: [ // build optimization plugins new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, filename: &apos;vendor-[hash].min.js&apos;, &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, drop_console: false, &#125; &#125;), new ExtractTextPlugin(&#123; filename: &apos;build.min.css&apos;, allChunks: true, &#125;), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // compile time plugins new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: &apos;&quot;production&quot;&apos;, &#125;), // webpack-dev-server enhancement plugins new DashboardPlugin(), new webpack.HotModuleReplacementPlugin(),]","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"VUE的webpack-simple模板","date":"2017-06-23T13:20:12.000Z","path":"2017/06/23/VUE的webpack-simple模板/","text":"","tags":[]},{"title":"RESTful","date":"2017-06-22T15:23:49.000Z","path":"2017/06/22/RESTful/","text":"","tags":[]},{"title":"表单脚本","date":"2017-03-15T02:45:08.000Z","path":"2017/03/15/表单脚本/","text":"表单基础知识表单独有的属性和方法获取表单的方式1.看成其他元素一样getElementById()2.document.forms 通过数值索引或name来获取12var firstForm = document.forms[0]; //获取页面第一个表单var myForm = document.forms[&apos;form2&apos;] //获取页面中name=form2的表单 提交表单通过&lt;input&gt; &lt;button&gt; 都可以定义提交按钮，type属性为submit即可123&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;button&gt;&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;&gt; 相应表单控件拥有焦点时，按回车就会提交表单（textarea例外，换行）使用submit()不用出发submit事件也能提交表单1234var form = document.getElemetById(&apos;myForm&apos;);//提交表单form.submit(); 解决重复提交问题1.提交表单后禁用提交按钮2.利用onsubmit事件处理程序取消后续表单提交操作 重置表单1.type为reset的 &lt;input&gt; &lt;button&gt;都可以2.form.reset(); 表单字段和DOM一样，表单也有elements属性12345678910var form = document.getElementById(&apos;&apos;);//通过索引var field1 = form.elements[0];//通过namevar field2 = form.elements[&apos;textbox&apos;];//获取字段数量var fieldCount = form.elements.length 文本框脚本input和textarea两种形式12345//单行文本 显示25字符 最多50字符 初始值为initial value&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt;//&lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt; 选择文本 select()select()方法 与 select事件 过滤输入","tags":[]},{"title":"正则表达式实战","date":"2017-03-10T02:01:50.000Z","path":"2017/03/10/正则表达式实战/","text":"匹配以数字结尾的； 正则：/\\d+$/g; 去掉空格；123var str = &quot;我 是 龙 恩&quot;;console.log(str.replace(/\\s+/g,&quot;&quot;));//我是龙恩 判断字符串是不是由数字组成； var str = “123344我 是 龙 恩 1123344”; console.log(/^\\d*$/.test(str)); //false var str2 = “123445566”; console.log(/^\\d*$/.test(str2)); // true 电话号码正则 分析如下：电话号码有区号(3-4位数字)，区号之后使用 ”-” 与电话号码连接； 区号正则：^\\d{3,4} 电话号码7~8位 正则 \\d{7,8} 电话号码也有分机号，分机号为3-4位数字，非必填项，如果要填写的话，则以”-”与电话号码相连接。 正则(-\\d{3,4})? 因此正则匹配电话号码正则为： /^\\d{3,4}-/d{7,8}(-\\d{3,4})?$/; 手机号码正则 手机号码需要匹配；手机号码开头不以0开始的，并且是11位数字，目前的手机号码有如下开头的：13,14,15,17,18开头的；因此正则如下： /(^1[3|4|5|7|8][0-9]{9}$)/ 如下测试代码： var str = 15606512345; var reg = /(^1[3|4|5|7|8][0-9]{9}$)/; console.log(reg.test(str)); //true 删除字符串左右空格 复制代码// 删除字符串两侧的空白 /* 下面的正则的含义是以1个或者多个空白开头的 | 是或者的意思 或者以1个或者多个空白结尾的 也就是去掉头部和尾部的1个或者多个空格 */ function trim(str) { return str.replace(/^\\s+|\\s+$/g,&apos;&apos;); } var str1 = “ 1234 “; console.log(trim(str1)); // 输出去掉空格的 1234复制代码 限制文本框只能输入数字和小数点(二位小数点) 分析：开头有0个或者多个数字，中间有0个或者1个小数点，小数点后面有0个或者最多2个数字； 正则： 复制代码/^\\d*.?\\d{0,2}$/ //测试代码如下：var reg = /^\\d*.?\\d{0,2}$/;var str1 = .9;console.log(reg.test(str1)); // true var str2 = 1.99;console.log(reg.test(str2)); // true var str3 = “1a.99”;console.log(reg.test(str3)); // false复制代码8.替换小数点前面的内容为指定内容 var href = “aa.php?d=1”; var reg = href.replace(/\\b^(\\w*)(?=.)/,”bb”); console.log(reg); // bb.php?d=1代码分析如下： 如上代码的含义是 使用正则replace替换操作 找出以字母数字下划线开头的字符，前面以\\b分隔单词与边界的地方 因此会找出第一个字符串中第一个开头的字符,后面是以捕获性分组来匹配 后面紧跟着一个.号的匹配，分组只匹配位置，不匹配字符，是零宽度的； 匹配中文的正则 使用 Unicode，必须使用\\u开头，接着是字符编码的四位16进制表现形式。 console.log(/[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/g.test(“我是”)); //true 返回字符串中 中文字符的个数。 分析:使用replace方法把不是中文字符全部替换成空 返回被替换的字符，因此是中文字符； 代码如下： 复制代码var str = “111我是涂根华说得对aaaaa1234556”; var reg = /[^\\u4E00-\\u9FA5\\uf900-\\ufa2d]/g; var val = str.replace(reg,’’); console.log(val); // 我是涂根华说得对 console.log(val.length); // 长度为 8复制代码 正则获取ip地址的前三段 比如如:192.168.16.162 需要变成 192.168.16 分析：使用正则匹配 .号后面带1-3位数字即可， 且以数字结尾的，把他们替换成空字符串。 代码如下： var ip = “192.168.16.162”; console.log(ip.replace(/.\\d{1,3}$/,””));// 192.168.16 匹配标签中的内容 比如匹配如代码 aaabbb 分析： 想获取ul中的内容，可以对匹配的内容使用分组 然后打印RegExp.$1 就获取到分组的内容了; 匹配所有字符 使用[\\s\\S]+ 空白和非空白的所有字符，且使用修饰符g代表全局的 如下代码： var str2 = “aaabbb“; str2.match(/([\\s\\S]+?)&lt;\\/ul&gt;/g); console.log(RegExp.$1); //aaabbb 匹配标签中的文本。 匹配文本思路：可以先把字符串内的所有标签替换成空字符串 因此返回的就是文本了； 正则/&lt;\\/?[\\s\\S]+?&gt;/gi 如下代码： var str3 = “aaabbb“; var c = str3.replace(/&lt;\\/?[\\s\\S]+?&gt;/gi,””); console.log(c); // aaabbb 正则获取文件名 文件名有如下几种： c:\\images\\tupian\\006.jpg C:\\006.JPG “c:\\images\\tupian\\006.jpg”; “c:\\images\\tupian\\aa.jpg”; “c:/images/tupian/test2.jpg”; 正则如：/[^\\\\/]*[\\\\/]+/gi; 上面的正则含义是：[^\\\\/]* 不以一个\\ 或者 2个\\ 或者 /(需要转义,使用)这样的反斜杠开头的 零个或者多个字符,后面紧跟以一个\\ 或者 两个\\ 或者 /(需要转义，使用)这样一个或者多个分隔符 全局匹配； 代码如下： 复制代码var s1 = “c:\\images\\tupian\\006.jpg”, s2 = “c:\\images\\tupian\\aa.jpg”, s3 = “c:/images/tupian/test2.jpg”; function getFileName(str){ var reg = /[^\\\\/]*[\\\\/]+/gi; str = str.replace(reg,’’); return str;}console.log(getFileName(s1)); // 006.jpgconsole.log(getFileName(s3)); // test2.jpg复制代码 绝对路径变成相对路径 比如绝对路径 http://172.16.28.162/images/a.jpg 需要替换成 ./images/a.jpg 使用正则匹配 http:// //需要使用转义字符转义的 继续匹配除/以外的任何一个字符 直到有反斜杠/为止；然后替换成 . 字符 代码如下： var reg = /http:\\/\\/[^\\/]+/g; var r1 = “http://172.16.28.162/images/a.jpg“; console.log(r1.replace(reg,’.’)); // ./images/a.jpg 用户名正则 匹配规则：只能是中文，英文，数字，下划线，4-16个字符； 匹配中文字符正则：/[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/ \\w是 匹配英文，数字，下划线 测试代码如下： 复制代码var reg = /^[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]{4,16}$/; var str = “我是12345678aa_123”; console.log(reg.test(str)); // true var str = “我是12345678aa_1235”; console.log(reg.test(str)); // 17位 false复制代码 匹配英文地址 匹配规则：包含点，字母，空格，逗号，数字，但是开头和结尾必须为字母 分析：开头必须为字母可以这样写 /^[a-zA-Z]/ 结尾必须为字母可以这样写：/[a-zA-Z]+$/ 中间包含点，字母，空格，逗号，数字的正则：/[.a-zA-Z\\s,0-9]*?/ 外面的*号是0个或者多个，后面的问号? 代表可有可无;有就匹配，没有就不匹配; 测试代码如下： 复制代码var reg = /^[a-zA-Z][.a-zA-Z\\s,0-9]*?[a-zA-Z]+$/; var str1 = “11aa”; console.log(reg.test(str1)); // false var str2 = “aa111aaa”; console.log(reg.test(str2)); // true复制代码18 匹配价格 匹配规则: 开头有0个或者多个数字，中间可能有一个小数点，后面有可能有0-2位小数 正则:/^\\d*(.\\d{0,2})?$/ 代码如下测试 复制代码var reg = /^\\d*(.\\d{0,2})?$/ var num1 = 12; console.log(reg.test(num1)); // true var num2 = .01; console.log(reg.test(num2)); // true var num3 = 1.01; console.log(reg.test(num3)); // true var num4 = “1.aa1”; console.log(reg.test(num4)); //false var num5 = “1.1a”; console.log(reg.test(num5)); //false复制代码 身份证号码的匹配 匹配规则：身份证号码有15位或者18位，其中最后一位可能是X，其他全是数字 正则： /^(\\d{14}|\\d{17})(\\d|[xX])$/ 复制代码var reg = /^(\\d{14}|\\d{17})(\\d|[xX])$/; var identity1 = “36232919578996x”; console.log(reg.test(identity1)); // true var identity2 = “36232919578996a”; console.log(reg.test(identity2)); // false // 16位 var identity3 = “362329195789961x”; console.log(reg.test(identity3)); // false复制代码 单词的首字母大写 匹配字符串，让其字符串的首个字母大写 正则：/\\b(\\w)|\\s(\\w)/g 测试代码如下： 复制代码function replaceReg(reg,str) { // 先转换为小写 str = str.toLowerCase(); return str.replace(reg,function(m){ return m.toUpperCase(); }); } var reg = /\\b(\\w)|\\s(\\w)/g; var str = “aadfdfCC”; console.log(replaceReg(reg,str)); // Aadfdfcc复制代码 验证日期格式 日期格式有2种 第一种是yyyy-mm-dd 或 yyyy/mm/dd 分析 月和天数可以有1位或者2位 正则：/^\\d{4}[-\\/]\\d{1,2}[-\\/]\\d{1,2}$/; 测试代码如下： 复制代码var reg = /^\\d{4}[-\\/]\\d{1,2}[-\\/]\\d{1,2}$/; var d1 = “2015-12-1”; console.log(reg.test(d1)); //true var d2 = “2015-12-02”; console.log(reg.test(d2)); //true var d3 = “2015/12/12”; console.log(reg.test(d3)); // true复制代码 验证邮箱的正则表达式 思路分析: 邮箱的规则是: 由3部分组成 由1个或者多个字母数字下划线和杠 + @ + 1个或者多个字母数字下划线和杠 + . + 1个或者多个字母数字下划线和杠 因此正则：/^([a-zA-Z_0-9-])+@([a-zA-Z_0-9-])+(.[a-zA-Z_0-9-])+$/ 测试代码如下： 复制代码var reg = /^([a-zA-Z_0-9-])+@([a-zA-Z_0-9-])+(.[a-zA-Z_0-9-])+/; var email1 = “tugenhua@126.com”; console.log(reg.test(email1)); //true var email2 = “879083421_aaAA@qqAAzz_AA.comaaa”; console.log(reg.test(email2)); // true复制代码 匹配代码中的a链接 比如222 匹配这样的 使用正则：/\\w*&lt;\\/a&gt;/gi; var html = “222344“; console.log(html.match(reg)); // [“222“] var html2 = “222344333“; console.log(html2.match(reg)); //[“222344333“]复制代码 正则判断标签是否闭合 没有闭合的标签有2种 类型 一种像img标签那样的 &lt;img src=”” 还有一种像div或者p标签那样的 aaa 分析：先匹配起始标签 如&lt;img 或 &lt;p 使用正则：/&lt;[a-z]+/i 接着匹配标签里面的多个属性 使用正则 /(\\s\\w?\\s=\\s.+?)(\\s?&gt;[\\s\\S]?(&lt;\\/\\1&gt;)+|\\s\\/&gt;)/i 因此整个正则表达式合并为 /&lt;([a-z]+)(\\s\\w?\\s=\\s.+?)(\\s?&gt;[\\s\\S]?(&lt;\\/\\1&gt;)+|\\s\\/&gt;)/i 正则分析如下： 首先我们匹配像img标签或者div标签的开头位置时候 &lt;img 或 &lt;div 使用正则 /&lt;([a-z]+)/i 以 &lt; 开始 [a-z]中任意一个字符，修饰符+是一个或者多个字符 i代表不区分大小写 (\\s\\w?\\s=\\s.+?)的含义是：比如&lt;img src = “” 或 &lt;div id = “” 先\\s匹配0个或多个空白 \\w* 匹配0个或者多个(数字或者字母或下划线) 后面的问号？(尽可能少的匹配) 接着\\s 匹配0个或者多个空白 = 号紧接后面的 \\s 也是匹配0个或者多个空白 .+? 的含义是匹配除换行符之外的任意一个或多个字符(尽可能少的匹配); 下面我们继续看标签的闭合 标签闭合有2种，一种像img这样的 还有一种是 这样的； 如果是类似img标签这样的话，匹配结束字符为 /&gt; 匹配正则为：(\\s\\/&gt;); 如果是div这样的话 正则为：(\\s?&gt;[\\s\\S]*?&lt;\\/\\1&gt;) &lt;\\/\\1&gt; 的含义是：指的是 ([a-z]+) 这个分组 整个正则 /&lt;([a-z]+)(\\s\\w?\\s=\\s“.+?”)(\\s?&gt;[\\s\\S]?&lt;\\/\\1&gt;)|\\s\\/&gt;/i 注意：在元字符* 或者 + 号后加一个问号(?) 目的是 尽可能少的匹配； 复制代码var reg = /&lt;([a-z]+)(\\s\\w?\\s=\\s“.+?”)(\\s?&gt;[\\s\\S]?&lt;\\/\\1&gt;)|\\s\\/&gt;/i; var str1 = ““; var str2 = ““; console.log(reg.test(str1)); // true console.log(reg.test(str2)); // true var str3 = “&lt;img src=’bb’”; console.log(reg.test(str3)); // false var str4 = “aaa”; console.log(reg.test(str4)); // false //但是如上正则对下面的这个demo列子就不适用了；相同的标签嵌套没有闭合的情况下 如下 var str5 = “aaa“; console.log(reg.test(str5)); // true 实际上是false 因为有没有闭合标签复制代码 获取标签里面的内容 正则和上面一样 只是使用了一个分组后，再获取那个分组即可； var str = “111“; str.match(/&lt;([a-z]+)(\\s\\w?\\s=\\s“.+?”)\\s?&gt;([\\s\\S]*?)&lt;\\/\\1&gt;/); console.log(RegExp.$3); // 111 正则判断是否为数字和字母的混合 规则：字母和数字的混合 正则如： /^(([a-z]+)([0-9]+)|([0-9]+([a-z]+)))[a-z0-9]*$/i 分析：^([a-z]+)([0-9]+) 含义是 以1个或多个字母开头 后面紧跟1个或者多个数字 ^([0-9]+([a-z]+)) 或者是以1个或者多个数字开头 后面紧跟1个或者多个字母 [a-z0-9]*$ 后面还可以紧跟数字或者字母0个或者多个 测试代码如下： 复制代码var reg = /^(([a-z]+)([0-9]+)|([0-9]+([a-z]+)))[a-z0-9]*$/i; var str1 = “aaaa”; var str2 = “aa22”; var str3 = “111sddtr”; var str4 = “问问啊啊啊ass”; var str5 = “1111ssdsd111sasddas”; console.log(reg.test(str1)); //false console.log(reg.test(str2)); // true console.log(reg.test(str3)); // true console.log(reg.test(str4)); // false console.log(reg.test(str5)); // true复制代码 将阿拉伯数字转换为中文大写字符 复制代码var arrs = [“零”,”壹”,”贰”,”叁”,”肆”,”伍”,”陆”,”柒”,”捌”,”玖”]; function replaceReg2(reg,str){ return str.replace(reg,function(m){return arrs[m];}) } var reg = /\\d/g; var str1 = ‘13889294444’; var str2 = ‘12889293333’; var str3 = ‘23445567’; console.log(replaceReg2(reg,str1)); // 壹叁捌捌玖贰玖肆肆肆肆 console.log(replaceReg2(reg,str2)); // 壹贰捌捌玖贰玖叁叁叁叁 console.log(replaceReg2(reg,str3)); // 贰叁肆肆伍伍陆柒复制代码 替换文本中的url为链接 比如一段文本中有 aaaaahttp://www.baidu.combbbbb 需要替换成 aaaaahttp://www.baidu.combbbbb 分析：最主要的还是需要正则匹配http://www.baidu.com 的url 正则如：/http:\\/\\/\\w(.\\w)+/ig; 测试代码如下： 复制代码var str1 = “aaaaahttp://www.baidu.com bbbbb”; //var reg = /http:\\/\\/\\w*(.\\w)+/ig; var reg = /http:\\/\\/\\w(.\\w)+/ig; function replaceUrl(reg,str) { return str.replace(reg,function(r){ return ““+r+”“; }); } console.log(replaceUrl(reg,str1)); // aaaaahttp://www.baidu.com bbbbb","tags":[{"name":"RegExp 正则","slug":"RegExp-正则","permalink":"http://yoursite.com/tags/RegExp-正则/"}]},{"title":"RegExp正则表达式","date":"2017-03-09T14:18:26.000Z","path":"2017/03/09/RegExp正则表达式/","text":"","tags":[]},{"title":"javascript中的闭包问题","date":"2017-03-09T06:14:03.000Z","path":"2017/03/09/javascript中的闭包问题/","text":"闭包简介闭包是JavaScript的重要特性，那么什么是闭包？ 《JavaScript高级程序设计(第3版)》中闭包的定义： 闭包就是指有权访问另一个函数中的变量的函数。 《JavaScript权威指南(第6版)》中闭包的定义： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”。 简单来说，在JavaScript中，函数是对象，对象是属性的集合，属性的值也可以是对象，在函数内定义函数就成为一种常见的情况，在函数内部声明函数innerFunction，在函数外部调用innerFunction，在这个过程中，就产生了闭包。 我们来看一个简单的例子：123456function checkScope()&#123; var scope = &quot;local scope&quot;; function f() &#123; return scope; &#125; return f();&#125;checkScope();//输出为“local scope” 当函数第一次被调用时，会创建一个执行环境以及相应的作用域链，作用域链的前端，始终都是当前执行代码所在环境的变量对象，作用域链中的下一个变量对象来自包含外部环境，下一个变量则来自下一个外部环境，这样一直延续到全局执行环境。 在上边的例子中，访问scope时，内部的f()函数可以访问f()外部的变量scope，因为它在作用域链中一级一级往上找的时候可以找到scope变量。 闭包的作用一、 模拟私有变量。在函数内创建一个闭包，闭包就可以通过自己的作用域链访问函数内部的变量，可以创建用于访问私有变量的方法。访问私有变量和私有函数的方法被称为特权方法。1234567891011function MyObject()&#123; var privateVariable = 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicFunction = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; 二、 模仿块级作用域。 JavaScript中没有块级作用域的概念，这意味着在块语句中定义的变量，实际上是包含在函数中的。如果临时需要一些变量，使用私有作用域。12345678910111213141516function block() &#123; var a = 1; var b = 2; (function () &#123; var a = 3;//覆盖了父作用域中的变量a var c = 4; //访问到了当前作用域中的变量 console.log(a);//3 //访问了父作用域中的变量 console.log(b);//2 //访问当前作用域中的变量 console.log(c);//4 &#125;)() //访问块级作用域中的变量 console.log(c);//c is not defined&#125; 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 循环中的闭包使用闭包时一种常见的错误情况是循环中的闭包，很多初学者都遇到了这个问题。很常见的一种情况就是给页面中的多个按钮绑定点击事件，JavaScript代码如下所示：12345678window.onload = function()&#123; var inupts = document.getElementsByTagName(&apos;input&apos;); for(var i = 0; i &lt; inupts.length; i++)&#123; inupts[i].onclick = function()&#123; console.log(i);//希望输出0,1,2,3,4... &#125; &#125;&#125; 页面中有5个按钮，根据上边的代码，我们需要的是依次点击按钮时，控制台分别打印出0，1，2，3，4，而实际上，控制台打印出来的，如下图所示： 这是为什么呢，当for循环执行完之后，i已经变成了按钮的个数5了，而所有点击函数绑定的都是同一个i，点击按钮时，打印出来的i也都变成了5了。 这一部分理解也可以参考http://www.cnblogs.com/qieguo/p/5457040.html。 那么我们为了得到想要的结果，需要在每次循环中创建变量i的拷贝，下面提供三种方法。 第一、使用匿名包装器1234567891011window.onload = function () &#123; var inupts = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; inupts.length; i++) &#123; (function (e) &#123; inupts[i].onclick = function () &#123; console.log(e); &#125; &#125;)(i); &#125;&#125; 依次点击按钮，控制台输出如下： 第二、从匿名包装器中返回一个函数：12345678910window.onload = function () &#123; var inupts = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; inupts.length; i++) &#123; inupts[i].onclick = function (num) &#123; return function () &#123; console.log(num); &#125;; &#125; (i); &#125;&#125; 首先，定义了匿名函数，并将立即执行该匿名函数的结果赋值给数组，匿名函数有一个参数num，在调用每个函数时，我们传入了变量i，函数按值传递，就将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，每个按钮点击函数都有自己num变量的一个副本，因此可以输出各自不同的数值了。 第三、在循环中使用let12345678window.onload = function () &#123; var inupts = document.getElementsByTagName(&apos;input&apos;); for (let i = 0; i &lt; inupts.length; i++) &#123; inupts[i].onclick = function () &#123; console.log(i); &#125;; &#125;&#125; let是ES6新增的命令，用法类似于var，但是所声明的变量只能在let命令所在代码块内有效。上述代码中，变量i是let声明的，当前的i只在本轮循环有效。所以每一次循环的i其实都是一个新的变量。关于let的用法可参考《ECMAScript 6 入门》中第二章。 内存泄漏产生内存泄漏的原因是IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些问题。(JavaScript垃圾收集机制可参考《JavaScript高级程序设计(第3版)》4.3) 例如：12345678function assignHandle() &#123; var element = document.getElementById(&apos;elementId&apos;); element.onclick = function () &#123; //element的onclick引用了匿名函数， //匿名函数又通过闭包引用了element，造成了循环引用 console.log(element.id); &#125;;&#125; 这个例子中，循环引用导致了element引用数至少为1，element所占内存就永远不会被回收，从而导致了内存泄漏问题。要解决这个问题，就需要解除对DOM对象的引用，减少引用数，确保正常回收其所占用的内存。 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再次访问这个值了，因而就可以将其占用的内存空间回收回来。 在采用引用计数策略的实现中，出现循环引用时，由于变量的引用次数永远不会是0，函数被多次调用时，就会导致大量内存得不到回收。 这一部分理解可以参考MDN中JavaScript内存管理。 结语JavaScript闭包是极其有用的特性，但是由于闭包会携带包含它的函数的作用域，占用更多内存，过多使用闭包可能会导致内存占用过多。","tags":[{"name":"closesure 闭包","slug":"closesure-闭包","permalink":"http://yoursite.com/tags/closesure-闭包/"}]},{"title":"学习javascript闭包","date":"2017-03-01T14:24:23.000Z","path":"2017/03/01/闭包/","text":"作者：阮一峰 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。12345 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。123456 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 六、思考题如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。代码片段一。12345678910 var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 代码片段二。123456789101112 var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());（完）","tags":[{"name":"closure","slug":"closure","permalink":"http://yoursite.com/tags/closure/"}]},{"title":"彻底理解javascript的回调函数（推荐）","date":"2017-02-24T07:05:53.000Z","path":"2017/02/24/彻底理解javascript的回调函数（推荐）/","text":"在javascript中回调函数非常重要，它们几乎无处不在。像其他更加传统的编程语言都有回调函数概念，但是非常奇怪的是，完完整整谈论回调函数的在线教程比较少，倒是有一堆关于call()和apply()函数的，或者有一些简短的关于callback的使用示例。 函数也是对象 想弄明白回调函数，首先的清楚地明白函数的规则。在javascript中，函数是比较奇怪的，但它确确实实是对象。确切地说，函数是用Function()构造函数创建的Function对象。Function对象包含一个字符串，字符串包含函数的javascript代码。假如你是从C语言或者java语言转过来的，这也许看起来很奇怪，代码怎么可能是字符串？但是对于javascript来说，这很平常。数据和代码之间的区别是很模糊的。 123//可以这样创建函数var fn = new Function(\"arg1\", \"arg2\", \"return arg1 * arg2;\");fn(2, 3); //6 这样做的一个好处，可以传递代码给其他函数，也可以传递正则变量或者对象（因为代码字面上只是对象而已）。 传递函数作为回调 很容易把一个函数作为参数传递。 12345678function fn(arg1, arg2, callback)&#123; var num = Math.ceil(Math.random() * (arg1 - arg2) + arg2); callback(num); //传递结果&#125;fn(10, 20, function(num)&#123; console.log(\"Callback called! Num: \" + num); &#125;); //结果为10和20之间的随机数 可能这样做看起比较麻烦，甚至有点愚蠢，为何不正常地返回结果？但是当遇上必须使用回调函数之时，你也许就不这样认为了！ 别挡道 传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。 但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用，甚至在这里强烈推荐使用！ 下面有个更加全面的使用AJAX加载XML文件的示例，并且使用了call()函数，在请求对象（requested object）上下文中调用回调函数。 123456789101112131415161718function fn(url, callback)&#123; var httpRequest; //创建XHR httpRequest = window.XMLHttpRequest ? new XMLHttpRequest() : //针对IE进行功能性检测 window.ActiveXObject ? new ActiveXObject(\"Microsoft.XMLHTTP\") : undefined; httpRequest.onreadystatechange = function()&#123; if(httpRequest.readystate === 4 &amp;&amp; httpRequest.status === 200)&#123; //状态判断 callback.call(httpRequest.responseXML); &#125; &#125;; httpRequest.open(\"GET\", url); httpRequest.send();&#125;fn(\"text.xml\", function()&#123; //调用函数 console.log(this); //此语句后输出&#125;);console.log(\"this will run before the above callback.\"); //此语句先输出 我们请求异步处理，意味着我们开始请求时，就告诉它们完成之时调用我们的函数。在实际情况中，onreadystatechange事件处理程序还得考虑请求失败的情况，这里我们是假设xml文件存在并且能被浏览器成功加载。这个例子中，异步函数分配给了onreadystatechange事件，因此不会立刻执行。 最终，第二个console.log语句先执行，因为回调函数直到请求完成才执行。 上述例子不太易于理解，那看看下面的示例： 12345678910function foo()&#123; var a = 10; return function()&#123; a *= 2; return a; &#125;; &#125;var f = foo();f(); //return 20.f(); //return 40. 函数在外部调用，依然可以访问变量a。这都是因为javascript中的作用域是词法性的。函数式运行在定义它们的作用域中（上述例子中的foo内部的作用域），而不是运行此函数的作用域中。只要f被定义在foo中，它就可以访问foo中定义的所有的变量，即便是foo的执行已经结束。因为它的作用域会被保存下来，但也只有返回的那个函数才可以访问这个保存下来的作用域。返回一个内嵌匿名函数是创建闭包最常用的手段。","tags":[{"name":"callback","slug":"callback","permalink":"http://yoursite.com/tags/callback/"}]},{"title":"前端之路","date":"2017-02-24T04:05:41.000Z","path":"2017/02/24/前端之路/","text":"转载请注明出处: https://github.com/qiu-deqing/FE-learning Table of Contents generated with DocToc FE-learning 必备基础技能 基本开发工具 学习方法和学习目标 入门之路 继续提高 一些个人经历 LingyuCoder的学习经历 工具 技能 语言基础 进阶 项目 未来 其他 入门书 一些不错的网站 历程 MrRaindrop的学习经历 缘起 项目，下一个项目 收集癖和知识管理 跟对神 读书 前端的定位 最后 byr论坛yiyizym的建议 FE-learning结合个人经历总结的前端入门方法，总结从零基础到具备前端基本技能的道路、学习方法、资料。由于能力有限，不能保证面面俱到，只是作为入门参考，面向初学者，让初学者少走弯路。 互联网的快速发展和激烈竞争，用户体验成为一个重要的关注点，导致专业前端工程师成为热门职业，各大公司对前端工程师的需求量都很大，要求也越来越高，优秀的前端工程师更是稀缺。个人感觉前端入门相对容易，但是也需要系统地认真学习，在打好基础后坚持学习，成为优秀前端工程师也只是时间问题。 学习任何知识最重要的都是兴趣，如果经过一段时间的学习感觉不喜欢，那可能强迫自己学习是很痛苦的，效果也不会好，毕竟这很可能就是以后很多年生存的技能。不过随着互联网行业的发展，前端必然是Web开发人员需要学习的知识，有时候是没有专业前端工程师一起合作的，所以即使不做专门的前端工程师，掌握基本的前端技能为工作带来方便。 后期邀请了一些同学分享学习经历。如果有同学愿意分享,欢迎push 必备基础技能前端技能汇总这个项目详细记录了前端工程师牵涉到的各方面知识。在具备基本技能之后可以在里面找到学习的方向，完善技能和知识面。 frontend-dev-bookmarks是老外总结的前端开发资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。 以下是个人觉得入门阶段应该熟练掌握的基础技能： HTML4，HTML5语法、标签、语义 CSS2.1，CSS3规范，与HTML结合实现各种布局、效果 Ecma-262定义的javascript的语言核心，原生客户端javascript，DOM操作，HTML5新增功能 一个成熟的客户端javascript库，推荐jquery 一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟， HTTP 在掌握以上基础技能之后，工作中遇到需要的技术也能快速学习。 基本开发工具恰当的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并解决问题，以下是个人觉得必备的前端开发工具： 文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便 浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持 调试工具：推荐Chrome自带的Chrome develop tools，可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等 辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools， 翻墙工具：lantern, 壁虎漫步（已被和谐） 学习方法和学习目标方法： 入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果 在具备一定基础之后可以上网搜各种教程、demo，了解各种功能的实际用法和常见功能的实现方法 阅读HTML，CSS，Javascript标准全面完善知识点 阅读前端牛人的博客、文章提升对知识的理解 善用搜索引擎 目标： 熟记前面知识点部分的重要概念，结合学习经历得到自己的理解 熟悉常见功能的实现方法，如常见CSS布局，Tab控件等。 入门之路以下是入门阶段不错的书籍和资料 HTML先看《HTML &amp; CSS: Design and Build Websites》1-9章，然后《HTML5: The Missing Manual》1-4章。 CSS先看《CSS: The Missing Manual》，然后《CSS权威指南》 javascript先看《javascript高级程序设计》，然后《javascript权威指南》 HTTP看HTTP权威指南 在整个学习过程中HTML CSS JavaScript会有很多地方需要互相结合，实际工作中也是这样，一个简单的功能模块都需要三者结合才能实现。 动手是学习的重要组成部分，书籍重点讲解知识点，例子可能不是很充足，这就需要利用搜索引擎寻找一些简单教程，照着教程实现功能。以下是一些比较好的教程网址 可以搜索各大公司前端校招笔试面试题作为练习题或者他人总结的前端面试题还有个人总结的面试题（带参考答案） http://code.tutsplus.com有各种各样的教程 MDN也有很多教程，更重要的是里面有详细的文档，需要查找某个功能时在Google搜索：xxx site:https://developer.mozilla.org http://www.html5rocks.com/zh/也有很多优质教程 http://www.sitepoint.com/ http://alistapart.com/ 原生javascript是需要重点掌握的技能，在掌握原生javascript的基础上推荐熟练掌握jQuery，在实际工作中用处很大，这方面的书籍有《Learning jQuery》或者去jQuery官网 建一个https://github.com/账号，保存平时学习中的各种代码和项目。 有了一定基础之后可以搭建一个个人博客，记录学习过程中遇到的问题和解决方法，方便自己查阅也为其他人提供了帮助。也可以去http://www.cnblogs.com/或者http://www.csdn.net/这样的网站注册账号，方便实用 经常实用Google搜索英文资料应该经常找到来自http://stackoverflow.com/的高质量答案，遇到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。 经典书籍熟读之后，可以打开前面必备基础技能部分的链接。认真读对应标准，全面掌握知识 继续提高有了前面的基础之后，前端基本算是入门了，这时候可能每个人心中都有了一些学习方向，如果还是没有。可以参考前面必备技能部分提到的那两个项目，从里面选一些进行发展学习。以下是一些不错的方面： Grunt：前端自动化工具，提高工作效率 less css：优秀的CSS预处理器 bootstrap：优秀的CSS框架，对没有设计师的团队很不错，与less结合使用效果完美 requirejs：AMD规范的模块加载器，前端模块化趋势的必备工具 Node.js：JavaScript也可以做后台，前端工程师地位更上一步 AngularJS：做Single Page Application的好工具 移动端web开发：智能手机的普及让移动端的流量正在逐步赶超PC端 Javascript内存管理：SPA长期运行需要注意内存泄露的问题 High Performance JavaScript(Build Faster Web Application Interfaces) Best Practices for Speeding Up Your Web Site：重要技能 一些个人经历LingyuCoder的学习经历上面的大神都总结得差不多了，我这里就胡扯一些吧 工具 chrome dev tools：前端开发调试利器，着重注意几个功能： console（废话） elements:元素样式调整，很常用 sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象 watch expression：通过表达式查看当前内存中的值 call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候） scope variables：作用域链上的变量，非常有用 network：抓包查看每个请求，非常重要，前后端联调必备 timeline：分析渲染、js执行等等各个阶段，性能优化利器 emulation：模拟移动端环境，mobile页面开发必备 一些插件: liveload: 修改页面后自动刷新，不用按F5 dimensions：直接在页面上测量的利器 livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中 image tool：测量，取色 UC二维码：移动端调试扫码必备 pagespeed，YSlow：页面性能分析和优化插件 马克飞象：优秀的在线markdown编辑器，快速写周报，做记录 sublime text3：编码方便，插件多，速度快，性能好 emmet：提升html编码速度必备 sublimelinter + 各种语言的lint和hint：代码纠错 一些snippets：自动补全，提升开发效率 Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能 Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件 GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子 iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备 Charles：Mac 平台最好用的抓包分析工具 Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用 Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便 技能前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说 语言基础JavaScript： 作用域链、闭包、运行时上下文、this 原型链、继承 NodeJS基础和常用API CSS： 选择器 浏览器兼容性及常见的hack处理 CSS布局的方式和原理（盒子模型、BFC、IFC等等） CSS 3，如animation、gradient、等等 HTML： 语义化标签 进阶JavaScript: 异步控制（Promise、ES6 generator、Async） 模块化的开发方式（AMD、CMD、KMD等等） JavaScript解释器的一些相关知识 异步IO实现 垃圾回收 事件队列 常用框架使用及其原理 jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研 AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦 underscore：优秀的工具库，方便的理解常用工具代码片段的实现 polymer/React: 组件化开发，面向未来，理解组件化开发的原理 CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理 DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程 解析HTML、CSS、JavaScript时造成的阻塞 HTML5相关 SVG及矢量图原理 Canvas开发及动画原理（帧动画） Video和Audio flex box布局方式 icon fonts的使用 常用NodeJs的package： koa express underscore async gulp grunt connect request 一些理念： 响应式Web 优雅降级、渐进增强 don’t make me think 网页可用性、可访问性、其中的意义 SEO搜索引擎优化，了解搜索引擎的原理 SPA的好处和问题 性能优化： 减少请求数量（sprite、combo） 善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式） 减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离） CSS的回流与重绘 项目 版本管理：首推Git，用过Git都不会想用SVN了 Git：本地版本管理的机制 SVN：远程中心的版本管理机制 自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并 Gulp：基于流构建，速度快、模块质量好 Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高 预处理和模板引擎 less：语法简单，但功能有限 jade、ejs、velocity等模板引擎，各有各的长处 coffee：python工程师最爱，我没用过 环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了 本地代理：ihosts 自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果 jasmine mocha 生态系统 npm bower spm 搭建一个属于自己的博客 git pages hexo jekyll 未来 Web Componets：面向未来的组件化开发方式 HTML模板 Shadow DOM Custom Elements HTML Import 移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发 其他有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方 对于业务的思考：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务 交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目 知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录 对新技术的渴望，以及敢于尝试 入门书入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书： 《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看 《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助 《编写可维护的JavaScript》 《JavaScript DOM编程艺术》学习JavaScript和DOM开发的必读之作。 《Node.js开发指南》：不错的Nodejs入门书籍 《深入浅出Node.js》：Nodejs进阶书籍，必备 《JavaScript异步编程》：理解JS异步的编程理念 《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书 《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西 《Don`t make me think》：网页设计的理念，了解用户行为，非常不错 《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题 《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习 《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助 《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识 《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想 《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门 一些不错的网站 github：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习 codepen：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件 echojs：快速了解js新资讯的网站 stackoverflow和segmentfault：基本上各种问题都能在上面获得解答 google web fundamentals：每篇文章都适合仔细阅读 static files：开放的CDN，很好用 iconfont：阿里的矢量图标库，非常不错，支持CDN而且支持项目 html5 rocks: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章 css tricks：如何活用CSS，以及了解CSS新特性，这里可以满足你 JavaScript 秘密花园 JavaScript初学必看，非常不错 w3cplus：一个前端学习的网站，里面的文章质量都挺不错的 node school：一个不错的node学习网站 learn git branch：一个git学习网站，交互很棒 前端乱炖：一个前端文章分享的社区，有很多优秀文章 正则表达式：一个正则表达式入门教程，非常值得一看 阮一峰的博客和张鑫旭的博客：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源 各路大牛的博客：这个太多了，就不贴了，知乎上有很全的 各种规范的官方网站，不懂得时候读规范 历程以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和W3C School上的教程，以及一些前端博客，如汤姆大叔的博客。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了… MrRaindrop的学习经历应qiu神的邀请分享一下前端学习经验，这里对前端知识体系架构就不做总结了，各位大神们的总结已经相当到位了，我就贡献几个个人认为还比较有用的链接大家研究研究就好，然后主要分享一下我在前端学习过程中遇到的问题和总结的经验教训吧，如果能帮到想要入门的FE初学者（我就姑且假定为本文的读者受众类型了），让他们少走点弯路，每走一步都知道自己下一步的方向，这是最好了。各位大神的总结和分享详见qiu神整理的FE-learning。 先说下，前端这个东西每个人都可以有适合自己的学习方法，这篇仅作参考，写的有点乱，各位凑合看。 缘起我是属于误打误撞进了前端，之前一直往做游戏的方向去来着，搞过游戏网站，玩过游戏引擎，比如unity，unreal这种商业引擎，捣鼓了几个游戏原型，不过自打研一进了实验室，直接就被导师派去写了js，导师给了我半个月时间让我写个基于百度地图api的数据展示页面，虽然这个时间还是相当宽裕的，不过之前没怎么写过js，也不会用地图api，于是我就一边啃着《Javascript权威指南》（犀牛书）一边参考实验室前人留下的“代码”，总算是把功能都写出来了。那个页面算我的js入门作了，也是我前端学习路线的开始。 现在想来，虽然指派了去做前端，但是一直做下去并做好还是得靠兴趣维持，当然前端是一个趣味性十足的技术领域，而且社区每天都很“热闹”。 项目，下一个项目我个人认为前端的学习，初学阶段你可以完全脱离开书本，以项目驱动。虽然我个人是从犀牛书开始啃的，不过如果你没有充足的时间，或者觉得啃大部头乏而无味的话，还是别像我这样。当然了如果决定啃书最好是把书里的例子都跟着敲一遍的。我上研之前没接触过js，4月份还没开学呢就被直接被导师甩了个百度地图api的项目到脸上，接着就是各种ERP，地图数据展示，虽然换着花样来一点不重样，不过基本上都是前端的活，SSH和android开发也打过酱油，整个实验室就我一个人写前端敢信？富客户端SPA时代的后端就是一个restful接口，代码量基本都在前端啊，写的我一个人怎一个爽字了得…期间跟着导师感受了一把创业，每天从7点搞到晚上10点，也算是经历了一段快速成长期。 掌握一门技术先掌握它的大体框架，想一个能实现的点子，做一个能跑就行的demo，再去完善它的细节，等到demo完成了，对这门技术有了一个感性的认识，再去啃书，收获会大很多。我从开始原生js写到jquery，再到extjs，再到angularjs，从导师指定技术，到自己做技术选型，一个项目接着一个项目的练，就跟打怪升级似的。当然没有项目就去自己创造项目，动手实现自己的想法是件有乐趣和成就感的事。 收集癖和知识管理前端学习有个特点，很多东西都很零碎，分散，需要你自己去整理、归纳和总结。在微博、知乎上follow了众多的大神，你不仅仅是为了听八卦，大神们的只言片语有时候留下的是无尽的余味，很有可能一个不经意提到的一个词就成为你下一个学习的目标。收集这些信息，善用google，提问，思考。就像游戏里的收集要素，前端学习也是充满搜集要素的一个“游戏”，只不过你需要一个知识管理工具来充当物品栏和仓库，我所知道的大牛们无一不是知识管理工具的重度使用者。以前用的oneNote，那时候还没绑定到云存储，现在基本上用evernote，笔记已经累计到1200+篇。书签一直打算用delicious，因为它是基于tag管理的，但一直没用起来。当然重点不在于这些工具，但是趁手的工具可以提高你的学习效率。最关键当然是随时保持旺盛的学习欲望，你的目标是了解有关前端的一切（当然不是所有都要掌握，因为毕竟你的精力有限，而且现实的说这也不太可能）。 跟对神这个可控性貌似不大…跟对老大这个就不多说了，一定程度要看造化。不过话说回来，多跟身边的高手交流是王道，这个高手不一定要多高，但是一定要对技术有热情。研一的时候热情高涨，每天7点进实验室门，然后发现有个家伙居然比我还早到。后来发现这家伙上午就走了，下午又来了，而且导师对此习以为常，原来这家伙晚上不睡觉通宵写代码，上午才跑回去睡。后来经常和这位神讨论问题，每次感觉经验值蹭蹭蹭的往上涨。然后实验室还有一位神，被前面这位通宵神形容为“只能望其项背，一直在追赶，从来没赶上”，两位神的特点都是什么都了解一点，所以什么都能跟你讨论得起来，我有段时间做了个读书计划，从c/c++到vc/mfc再到unix网络编程，最后一路看到java核心技术和MSDN上的C#编程指南，和神们也能扯得很high了。 总之就是这两位神把我拉进了坑，或者说从一个坑跳进另一坑，虽然两位神都不是搞前端的，不过技术之间总有相通之处。 读书读书，多读书，读好书。在刘未鹏的博客里看到过一个公式，你第一个月的工资等于之前买过（读过）的技术书价格总和（这里说的技术书指那些经典的公认的好书）。讨论这个公式的正确性似乎没什么意义，然而它的合理性是毋庸置疑的，那就是多读经典技术书。最极端的一个例子，google的徐宥在我的大学里面说他扫荡了图书馆的整个TP312书架…对于前端的经典书籍，后面列了一个我收集的前端书列（如果有遗漏的前端经典好书，还请留言告诉我），有条件可以尝试刷一遍这些书，我也是在找完整的时间去啃完它们。之前说的，前端知识点松散，收集零散的知识点，从博客里快速学习等，这些只是前端学习的一个方面，如果你要想深入理解一个知识体系，了解它的来龙去脉，对它建立系统认识，读经典书还是必不可少的。 我从最开始啃完犀牛书，然后接着去看了其他一些和前端干系不大的经典技术书，再后来通过实验室的项目和自己弄的一些小项目逐渐对前端领域比较上路以后，又看了《Javascript模式》、《Javascript设计模式》、《编写可维护的Javascript》，后来了解到node并开始用node搞点小玩意儿，又看了本《NodeJS up and run》和《Mongodb权威指南》，不过感觉前者略坑。那会儿朴灵那本深入浅出（晒书么么哒）还没出，后来出了就去图书馆借来看完，这么看下来感觉还不错，不过感觉看的还是偏少了，还需要继续刷（参照上面的书列）。 前端的定位前端的定位关乎到你需要吸收什么样的知识和技能，决定在技术世界里你对什么需要格外敏感。如果你认为前端仅仅停留在切页面，实现交互和视觉的要求，那你对前端的认识还停留在初级阶段。阿里终面的时候我问了考官这么个问题：前端技术日新月异，范围越扩越宽，标准越来越丰富，似乎任何一个触角都能伸出很远。怎么给前端一个合适的定位？考官给我分析了半天，然后总结成一句话，就是用户和网站的联结者，用户体验的创造者（原话不是这样，但大体是这个意思）。也就是说前端的终极目标其实就是创造用户体验，提升用户体验，以用户体验为中心。不管你是从交互设计上下手，还是从性能优化出发，或者改进工作流提升工作流效率，最终都是为了创造和提升用户体验，最终都要体现到用户体验这一点上来。我认为这个总结非常有道理（当然“用户体验”这个词太宽泛了，并且不仅仅是前端工程师的范畴，比如开发后台的时候对一个数据处理过程进行优化，提升了整体性能，这也是对用户体验的一个提升）。 现在的前端工程师做到一定阶段不可避免会接触到很多比切页面、实现视觉要求、实现交互等更深入的问题，比如前端自动化、图像编程、性能优化等等，再往后推一点就是PHP/JSP/ASP/nodeJs，过去后端模板一般属于后端的范畴，现在随着前端架构的演进，可能会让你去写后端模板的代码，需要用到后端语言（PHP/Java/C#等），这就是所谓大前端（然而这与前端的定位并不是相背离的，大前端处理的依然是与用户接触的部分，仍然是对用户体验的优化）。可能最常见或者被谈论最多的就是node，其实这几种技术选型都可以，bat三家据说百度用PHP比较多，阿里用node比较多。 玉伯在他的博客里提过所谓全端是横向的，全栈是纵向的。全端即所有的终端说白了都是前端，因为都关乎到用户体验，直接和用户接触。适应多终端的开发，要求你在web前端的基础上，可能还要去扩展android开发和ios开发的知识，好在由于hybrid开发方式的流行，对使用native语言开发的技能会要求的不那么深入。 全栈可以说是最适合初创公司的一种发展类型，广义上认为是从前端干到后端，从开发干到运维，这种就不说了，一般人应该不会想要去往这个方向发展，想要成为这种意义上的full-stack dev的，可能用不着来看我这篇文章了；而狭义上的全栈特指使用js语言从前端写到架设在nodeJs上的后端，前后端统一语言，统一编程模型，甚至公用同一套代码。更多了解全栈开发可以看看玉伯这篇说说全栈工程师。 以上是我对前端以及衍生出来的技术路线的一些浅薄理解，学习一个领域掌握它的整体上的走向和趋势还是挺重要的。另外如果想要对前端学习方向、职业成长路径有一个整体的认识，推荐看看拔赤总结的这篇前端开发十日谈。 最后贡献几个对前端学习、面试有帮助的链接： 前端面试问题合集（Front-end-Developer-Interview-Questions） 前端技能汇总（JacksonTian） 另一张前端技能汇总图 前端那点事儿（书列） byr论坛yiyizym的建议与grunt相比，学习gulp会比较简单 做SPA的话，推荐backbone.js和 backbone.marionette.js 翻墙不用折腾，花十块钱买一个月的 红杏。 把基础打扎实了再学这些都没问题。 html 没什么好说的，有空学学html5。 css 尽量看文档 ，因为很多中文资料都各执一辞，看多了反而会糊涂。 有个网站可以查找html/css标签、属性在各个浏览器中的支持情况，挺好用的。 javascript 就看 javascript高级程序设计 。不过这么厚的书看过就会忘。对javascript核心概念的讲解：对象/原型链/ 构造函数/执行上下文/作用域链/闭包/this，这里有篇不错的文章。 有闲情可以看看 ecmascript 6。阮一峰的网站有入门资料。 jquery 有很多 API,这个网站可以方便查到。有时间弄清楚jquery deferred 的用法。 多给 sublimetext 装插件，比如说检查代码错误的，新建目录文件的，整理代码的。","tags":[{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/经验/"}]},{"title":"一个FlexBox小任务","date":"2017-02-23T13:48:27.000Z","path":"2017/02/23/一个FlexBox小任务/","text":"任务目的学习如何flex进行布局，学习如何根据屏幕宽度调整布局策略。任务描述 需要实现的效果如效果图（点击打开）所示，调整浏览器宽度查看响应式效果，红色的文字是说明，不需要写在 HTML 中。 任务注意事项只需要完成HTML，CSS代码编写，不需要写JavaScript屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。思考 Flexbox 布局和网格布局的异同，以及分别适用于什么样的场景。可以搜索一下别人的结论，不过要保持思辨的态度，不可直接接受别人的观点。HTML 及 CSS 代码结构清晰、规范 任务协作建议团队集中讨论，明确题目要求，保证队伍各自对题目要求认知一致各自完成任务实践交叉互相Review其他人的代码，建议每个人至少看一个同组队友的代码相互讨论，最后合成一份组内最佳代码进行提交 在线学习参考资料Flexbox详解：了解 Flexbox 属性的含义 图解 CSS3 Flexbox 属性：看完这两篇，对 Flexbox 的了解就够了，多实践一下，理解会更深刻 Flexbox——快速布局神器 使用 CSS 弹性盒 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;t1_10&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/t1_10.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@media screen and (min-width: 640px) &#123; .wrap &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row nowrap; /* Then we define how is distributed the remaining space */ justify-content: space-around; align-items: center; &#125;&#125;@media screen and (max-width: 639px) &#123; .wrap &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: flex-start; align-items: flex-start; &#125; ul li:last-child &#123; order: -1; &#125;&#125;.wrap &#123; margin: 20px; list-style-type: none;&#125;li:nth-child(1) &#123; border: 1px solid #f00; width: 150px; height: 120px;&#125;li:nth-child(2) &#123; border: 1px solid #f00; width: 150px; height: 100px;&#125;li:nth-child(3) &#123; border: 1px solid #f00; width: 150px; height: 40px;&#125;li:nth-child(4) &#123; border: 1px solid #0f0; width: 150px; height: 200px;&#125;","tags":[{"name":"FlexBox","slug":"FlexBox","permalink":"http://yoursite.com/tags/FlexBox/"}]},{"title":"FlexBox 弹性盒子详解","date":"2017-02-23T08:56:38.000Z","path":"2017/02/23/FlexBox-弹性盒子详解/","text":"flex布局模型不同于块和内联模型布局，块和内联模型的布局计算依赖于块和内联的流方向，而flex布局依赖于flex directions.简单的说：Flexbox是布局模块，而不是一个简单的属性，它包含父元素(flex container)和子元素(flex items)的属性。 主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。 主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。 主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。 侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。 侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。 侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是”width”或”height”属性，由哪一个对着侧轴方向决定。 Flexbox使用示例水平竖直居中下面这个例子是我们用的很多的完全居中（上下左右居中），我们可以用很多种方法实现，但目前只有用Flexbox实现是最为简单的。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;center&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"./center.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"parent\"&gt;&lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617body&#123; padding: 0; margin: 0;&#125; .parent &#123; display: flex; height: 300px; /* Or whatever */ background-color: black;&#125; .child &#123; width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */ background-color: white;&#125; 在Flex容器中，当项目边距设置为“auto”时，设置自动的垂直边距将使该项目完全集中两个轴。 六个子元素布局再看一个例子，将子元素的数量增加到六个。六个子元素随着浏览器大小改变布局而不需要用媒体查询。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;six&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./six.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"flex-container\"&gt; &lt;li class=\"flex-item\"&gt;1&lt;/li&gt; &lt;li class=\"flex-item\"&gt;2&lt;/li&gt; &lt;li class=\"flex-item\"&gt;3&lt;/li&gt; &lt;li class=\"flex-item\"&gt;4&lt;/li&gt; &lt;li class=\"flex-item\"&gt;5&lt;/li&gt; &lt;li class=\"flex-item\"&gt;6&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041body&#123; margin: 0; padding: 0;&#125;ul &#123; margin: 0; padding: 0;&#125;li&#123; list-style: none;&#125;.flex-container &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around;&#125;.flex-item &#123; background: tomato; padding: 5px; width: 200px; height: 150px; margin-top: 10px; line-height: 150px; color: white; font-weight: bold; font-size: 3em; text-align: center;&#125; 实现图中效果，需要设置三个属性：flex-direction: row; flex-wrap: wrap; justify-content: space-around;下节将介绍各属性。","tags":[{"name":"FlexBox","slug":"FlexBox","permalink":"http://yoursite.com/tags/FlexBox/"}]},{"title":"移动WEB布局","date":"2017-02-23T08:27:08.000Z","path":"2017/02/23/Hello-移动WEBEB/","text":"CSS Pixel与绝对像素之前在电视的webview上投放广告页面时，遇到了个问题，就是视窗大小和文档大小不一致。最后发现原来有CSS Pixel这个概念，搜集了一些资料，希望能把这个问题捋捋清楚。 首先提出一个大家常常会忽略的问题： 如今主流手机屏幕的像素点数已经远远超过了桌面显示器的像素数量，5.5英寸1920x1080P的手机与一个21英寸1920x1080P的显示器相比，同等面积下，手机的像素点更密集，可想而知，在手机屏幕上一个像素点是非常小的。 那么在CSS中设置font-size:12px，如果“手机屏幕物理像素：CSS像素”=“1：1”，那么手机上展示出来的字体你可能需要放大镜才能看清，但为什么如今的手机屏幕依然能清晰的显示？ 答案就是：CSS中的px与屏幕上的物理像素px不是等同的。 逻辑分辨率与物理分辨率由于以上物理像素尺寸差异导致的问题，我们不可能把电子文件中的像素与物理像素做1：1的适配。必须在小的设备上适当放大，也就是说用多个物理像素来显示一个电子像素，从而保证阅读质量。所以devicePixelRatio应运而生：逻辑分辨率 = 物理分辨率 / devicePixelRatio 普通密度桌面显示屏的devicePixelRatio=1高密度桌面显示屏(Mac Retina)的devicePixelRatio=2主流手机显示屏的devicePixelRatio=2或3 因为大部分桌面显示器的devicePixelRatio为1，所以在PC端我们感受不出来CSS Pixel 与 物理像素的差别。 举个栗子来说，一张100x100的图片，通过CSS设置它width:100px;height:100px。在电脑上打开，没有什么问题，但是在手机上打开，屏幕按照逻辑分辨率来渲染，假设手机的devicePixelRatio=3，那么就相当于拿3个物理像素来描绘1个电子像素。这等于拿一个三倍的放大镜去看你的图片，你的图片可能因此变得模糊，因为细节不够。所以一般明智的做法是把图片换成300x300的，CSS宽高不变，这样在手机上展示时，CSS宽高换算成物理像素是300x300，你的图片也是300x300，就不会变糊了。 移动开发方案打开一个页面，移动端浏览器会自动寻找&lt;meta name=&#39;viewport&#39;&gt;,如果指定了视窗口的width，就会把页面放到指定width的viewport里面。如果没有指定，则默认值有的是980，具体根据浏览器来定的。（我遇到的就是这个问题，通过添加下面的代码解决） width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放","tags":[{"name":"flexbox","slug":"flexbox","permalink":"http://yoursite.com/tags/flexbox/"}]},{"title":"清除浮动的常用方法","date":"2017-02-23T07:11:11.000Z","path":"2017/02/23/after伪类去除浮动/","text":"清楚浮动的常用方法 额外标签法 使用:after 伪元素 给父元素定高 利用overflow:hidden;属性 父元素浮动 父元素处于绝对定位 在开发网页的时候经常需要用到各种浮动，此时便需要及时的清除浮动，否则将会导致布局出现问题 引出问题： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .outer&#123; border: 1px solid black; width:300px; &#125; .inner&#123; width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; &#125; .footer&#123; background-color: #005FC3; width: 200px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看出本应包住3个 inner DIV的 outer DIV 却没有包住他们，此刻只剩一条由上下边框贴合组成的线，同时 footer DIV元素也跑到了三个浮动元素的底下 解决办法：1.使用额外标签法12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .outer&#123; border: 1px solid black; width: 300px; &#125; .inner&#123; width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; &#125; .footer&#123; background-color: #005FC3; width: 200px; height: 100px; &#125; .clearfix&#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"clearfix\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 增加了一个class=clearfix的div标签 2.使用:after伪元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .outer&#123; border: 1px solid black; width: 300px; &#125; .inner&#123; width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; &#125; .footer&#123; background-color: #005FC3; width: 200px; height: 100px; &#125; .clearfix:after&#123; /*最简方式*/ content: ''; display: block; clear: both; &#125; /* 新浪使用方式 .clearfix:after&#123; content: ''; display: block; clear: both; height: 0; visibility: hidden; &#125; */ .clearfix&#123; /*兼容 IE*/ zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer clearfix\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]